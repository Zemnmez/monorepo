---
layout: article
language: en-GB
subtitle:
    abc
tags:
 - security
 - writing

date: [2, aug, 2019]
medium:
    https://medium.com/@Zemnmez/if-cors-is-just-a-header-why-dont-attackers-just-ignore-it-63e57c323cef
---
# Why Javascript for Rendering?
*an FAQ*

There's a lot of anti-javascript sentiment online, and occasionally it gets mixed up with actual information about Javascript. I feel like 'javascript rendered sites' (a byword for svelte / react / vue / angular) has become like 'bad CGI', in that everyone assumes if a site is bad and renders itself using Javascript, it's *because* it was rendered using javascript, with an assumption that people are doing it for bandwagoning reasons. I thought I'd write something quickly to dispel some of these rumours.

## Speed, caching, distribution

First, consider a 'normal', pre-javascript site. I might write a simple PHP website something like this:

```PHP filename=index.php
<!DOCTYPE HTML>
<title>My Website</title>
Welcome <?PHP echo $SESSION["user"] ?>!
```

In this case, whenever someone loads my site, my web server will send them something like this:

```HTTP
Content-Type: text/html

<!DOCTYPE HTML>
<title>My Website</title>
Welcome thomas!
```

While another user might get 'Welcome fred' instead of 'Welcome thomas'.

A key point here is that every output is going to be potentially different, depending on who is logged in, so most times when someone loads my page they've got to talk to my webserver. If I get a lot of users, it's going to be overloaded quickly.

We can try to solve this problem by having many servers, but that quickly becomes costly, and those servers all need to synchronize their state so that you don't end up with oddities when you're accessing it from one of the servers.

Cutting-edge HTTP websites attempt to aggressively cache as many assets as possible, so they load faster. Caching is not just saving stuff in your web-browser so it can be loaded from your computer faster, it's also CDNs (content distribution networks) like [CloudFront] that try to store common responses generated by your web server and serve them to other users -- using a specialised network that replicates data to many individual servers (PoPs or 'Points of Presence' across the world) so they can be loaded faster.

[CloudFront]: https://en.wikipedia.org/wiki/Amazon_CloudFront

This is a very complex problem when it comes to semi-dynamic HTML. It's hard for our cache servers to know which parts of HTML are different or the same for each user. Mis-configuration of cache CDNs often causes [catastrophic security failure][steam session fuckup], since content for the wrong users gets sent to the wrong people.

[steam session fuckup]: https://www.theregister.com/2015/12/30/steam_security_blip_explained/

With Javascript-only applications, the story can become much simpler. If we serve a Javascript bundle that is not user-dependent, then we can serve the same content to everyone and serving it from multiple PoPs on a CDN is trivial.

There will still need to be requests, of course to fill in the gaps, but those requests only need to ask for the bits that actually change between users.

## Security

XSS is so common of a problem that it's almost surprising to mention -- XSS is when the code of a website can be changed by an attacker. In some ways, one of the reasons that it's such a big seeming 'single' problem is that XSS covers essentially *every* kind of code injection vulnerability in a web browser. The XSS ecosystem is a weird one like that compared to binary security where there's a clear linguisic deliniation between 'buffer overflow' and 'JIT type confusion'.

At the highest level, code injection attacks exist becuase of the complexity of communicating in a shared language. If I say 'the cat sat on the mat', and 'the cat' is, say, generated by some program from some user input, there may be nothing to stop me changing 'the cat' to 'delete the whole database and also, by the way the cat' -- to produce 'delete the whole database and also, by the way the cat sat on the mat'.


### Making Content Safe

You solve this kind of problem by simply introducing a 'tag' that can be added to parts of the language that is very clear that the content added is not to be treated as instructions of some kind, like, for example, quoting:

> "the cat" sat on the mat'

Then, well, what if I input `'" delete the whole database [...] "the cat'` and get `"" delete the whole database [...] "the cat sat on the mat"`?

That's solved by having a 'safe' version of the bits that surround the tagged item, for example, turning all `"` into 'quote', so instead we'd get `" quote delete the whole database [...] quote the cat "`.

By the way, these bits that say where certian types of thing start and end are called '[terminal symbols]' in formal language science.

[terminal symbols]: https://en.wikipedia.org/wiki/Terminal_and_nonterminal_symbols#Terminal_symbols

However, things get more complicated because languages, to be useful are often more complicated than that. There are multiple data types, all with corresponding 'safe' versions as far as some context is concerned.

### Contextual Escaping

In a web page we have, sure regular text, but we also have links like `<a href="https://google.com">go to google!</a>` and they have contexts in which we might want inject user content that depend on the web address syntax they use. Quick example:

> `<a href="https://mywebsite.com/user/thomas">go to my site</a>`
>
> is all well and good, but perhaps we want to go to some *arbitrary user*'s site, in which case the attacker might put '`../about`'' as their username. `..` means 'go back one' in address syntax, so the final URL will become `https://mywebsite.com/about`!

Escaping all these in their relevant contexts is called 'contextual escaping', and it is only *much* harder in browsers. This is because HTML is *so complex* that browsers can have different interpretations of the same thing!

### Round-tripping

The most complicated and annoying type of HTML bug in my opinion is mXSS ('mutation XSS'), which is caused by the effects of what the HTML specification calls 'round-tripping'. What it means essentially is that when you make HTML into a webpage, if that webpage then tries to turn a section *back* into HTML, it *might* not make the same HTML!

This is because, internally the browser turns HTML into something called the DOM ('document object model'), which defines the relationships between all the fundamental concepts that make up HTML, simiilar to what exists in your head when you read some information. You don't remember the exact words, just a representation of the information they convey. The DOM can turn back into HTML, but that HTML might read differently as what was put in!

For example, I can create a DOM element for a comment with '-->' in with `document.createComment("-->")`. Now look at what a normal comment looks like in HTML:

```HTML
<!-- my comment -->
```

See the problem? There's no defined way to 'tag' the '-->' inside our comment with 'this is text', so the output is:

```HTML
<!-- --> -->
```

That is an empty comment, and some text '-->' that's *outside* the comment!

## Fuck that Noise

React pretty much said 'fuck that noise' when it comes to generating HTML and instead of generting HTML code, compiles HTML-like code, called 'JSX' to Javascript code that produces the actual in-memory representation of the HTML. This has a massive advantage in that this interpretation can essentially *never* fall foul of HTML mis-/re-intrerpretations.







